---
title: Часть 1. Моделируем домен
description: В этой части серии мы поговорим о том, что такое доменная модель, чем она полезна и как мы можем использовать функциональное программирование, статическую типизацию и DDD для упрощения моделирования.
datetime: 2023-05-03T12:00
slug: /blog/explicit-design-1
cover: /images/content/explicit-design-series/01-app-and-world.png
tags:
  - architecture
  - communication
  - dev
  - fp
  - patterns
  - react
  - refactoring
  - tdd
  - testing
  - ts
---

# Часть 1. Моделируем домен

Продолжаем серию постов и экспериментов о разработке и проектировании приложений. В [прошлом посте](/blog/explicit-design-series) мы определили принципы, которых собираемся придерживаться при разработке приложения, и проблемы с кодом, которых хотим избежать. В этом посте мы поговорим о том, что такое доменная модель, чем она полезна и как мы можем использовать функциональное программирование, статическую типизацию и DDD для упрощения моделирования.

Мы подумаем, как вписать ограничения предметной области прямо в код и упростить его тестирование. Спроектируем потоки и преобразования данных, которые участвуют в сценариях приложения, и обсудим как говорить с продукт-оунерами, дизайнерами и другими «людьми из бизнеса» на одном языке.

## Доменная модель

Чтобы написать приложение, нам первым делом надо понять, что оно будет делать — то есть описать набор пользовательских сценариев, задач, которые приложение будет решать, а также различных правил и ограничений его предметной области. В [методологии DDD (Domain-Driven Design)](https://martinfowler.com/bliki/DomainDrivenDesign.html) такой набор знаний называют [_доменной моделью или доменом_](https://martinfowler.com/eaaCatalog/domainModel.html).

Далее мы попробуем спроектировать конвертер и описать его модель в виде типов и функций. Конечный результат и исходники всех примеров из этого поста вы сможете найти [на Гитхабе](https://github.com/bespoyasov/explicit-design).

### Польза моделирования

Главная цель доменной модели — помочь нам [справляться со сложностью](/blog/domain-modelling-made-functional/) и хаотичностью настоящего мира. Модель — это такой ограниченный «слепок реальности», который мы можем поместить в голове и выразить в коде.

Из-за того, что модель всегда проще реальности, она включает в себя не все детали предметной области, а только те, которые мы считаем важными. И первый шаг в проектировании — это понять, какие детали мы хотим включить в модель.

### Исследование предметной области

Скотт Влашин в своей книге [«Доменное моделирование в функциональном стиле»](/blog/domain-modelling-made-functional/) для исследования предметной области и первого шага моделирования предлагает «программировать ногами». Он предлагает опрашивать людей, которые не связаны с кодом, но разбираются в предметной области, которую мы хотим описать. Такими людьми могут быть, например, продукт-оунеры, UX-проектироващики или бизнес-заказчики.

Цель опросов — обнаружить и формализовать как можно больше правил и ограничений, по которым живёт тот мир, который мы моделируем. Например, перед разработкой конвертера, мы можем поинтересоваться:

- Между какими валютами мы будем проводить конвертацию?
- Какую точность подсчёта мы хотим видеть?
- Откуда мы берём котировки? Как часто они меняются?
- Можно ли пользователю менять валюты расчёта?
- Как мы хотим работать с «отрицательными значениями»?
- ...И так далее.

Иногда при опросах мы можем натолкнуться на «противоречия» или «нестыковки». Это признак того, что мы не до конца поняли детали домена и нам стоит задать много уточняющих вопросов. На стоит бояться задать «глупый» вопрос, потому что наша картина мира может сильно отличаться от картины мира продукт-оунера или заказчика.

Чем больше крайних случаев и «противоречий» мы найдём с помощью опросов, тем корректнее будет наше понимание предметной области. А чем точнее понимание, тем меньше ошибок мы допустим при моделировании и меньше проблем будет при развитии приложения.

### Ограниченность и детали

С другой стороны перенасыщать модель ненужными или малозначимыми деталями тоже не стоит. Чем проще модель, тем [легче замечать](https://en.wikipedia.org/wiki/Signal-to-noise_ratio) в ней ошибки и несоответствия с реальностью.

Наша задача — достать столько информации, сколько необходимо, чтобы _начать_ описывать правила домена. Со временем мы будем дополнять и уточнять модель, возвращаясь и прорабатывая различные её части.

Более того какие-то детали предметной области мы не будем включать в модель _вовсе_. Например, в конвертер мы не будем включать детали того, _как_ устанавливаются котировки валют. Нам важно лишь то, откуда мы их берём и в каком виде их получим. Такие детали полезно знать и учитывать, но не обязательно отражать в коде, чтобы не засорять его.

<SideNote>
  О том, как выбрать, какие детали включать в модель, а какие нет, хорошо написано у Эрика Эванса в
  [“Domain-Driven Design”](https://www.goodreads.com/book/show/179133.Domain_Driven_Design) и Скотта
  Влашина в [“Domain Modelling Made Functional”](/blog/domain-modelling-made-functional/).
</SideNote>

### Нюансы моделирования

Стоит отметить, что не у каждого приложения в принципе может быть богатая доменная модель. Если мы пишем простенький [CRUD](https://ru.wikipedia.org/wiki/CRUD)-app, то сложной бизнес-логики в нём не будет. Функциональность такого приложения ограничится запросами к серверу и отображением полученных данных на экране, и выделять модель может быть не нужно.

## Ядро приложения

Во многих архитектурных стилях типа [портов-адаптеров](https://herbertograca.com/2017/09/14/ports-adapters-architecture/) или [чистой архитектуры](https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/) доменная модель находится в самом центре приложения — так называемом _ядре_. Кроме домена там содержится код пользовательских сценариев и спецификации того, как «подружить» эти сценарии с реальным миром (браузером, сторонними API и библиотеками).

![Приложение в окружении внешнего мира](/images/content/explicit-design-series/01-app-and-world.png)

Мы воспользуемся этой метафорой и будем описывать бизнес-логику конвертера как такое вот «ядро приложения».

Условимся, что мы уже провели исследование предметной области и получили ответы на вопросы из списка выше. В момент, когда у нас в голове появляется понимание предметной области, мы можем начать проектировать модель.

### Процессы в виде типов

Доменная модель конвертера не очень большая, и по ответам на вопросы из списка выше мы можем примерно сообразить, как он будет работать.

Мы можем представить, что при вводе значения одной валюты, мы рассчитываем значение второй относительно известных котировок. Такие преобразования в конечном итоге мы выразим как _функции_, но сейчас писать именно функции пока рано. Сперва мы напишем черновик модели в _типах и сигнатурах_.

Польза начального проектирования на типах в том, что их проще и [дешевле исправлять](/blog/domain-modelling-made-functional/), чем готовый код функций. При этом такая модель всё ещё помогает понять поведение системы и даже выявить ошибки или недостающие данные, чтобы задать больше уточняющих вопросов. Каждое уточнение будет менять типы модели и фиксировать в ней больше знаний о предметной области.

Затем, когда мы увидим, что модель в типах достаточно проработана, мы приступим к «реализации» её в функциях.

<SideNote>
  Вообще, такой подход с разделением на «уровень проектирования» и «уровень реализации» мы буем
  использовать довольно часто. Например, мы используем его при композиции фич и приложения в целом,
  при проектировании юзкейсов и даже при написании тестов.
</SideNote>

Попробуем смоделировать процессы, через которые проходят данные в конвертере. Первый такой процесс — это определение курса для выбранной пары валют. Нам потребуется получить котировки всех валют, а также коды базовой и квот-валюты, и затем достать из котировок их курс:

![Чтобы найти нужный курс, нам надо знать коды базовой и квот-валюты, а также котировки, которые содержат эту пару](/images/content/explicit-design-series/01-lookup-rate.png)

Второй процесс — расчёт значения квот-валюты на основе значения базовой валюты. Для него нам нужен курс выбранной пары валют и значение базовой:

![Когда мы знаем курс между выбранными валютами, мы можем посчитать значение квот-валюты относительно базовой по этому курсу](/images/content/explicit-design-series/01-calculate-quote.png)

Третий процесс — нормализовать значения, которые мы получаем от пользователя. Наша модель будет работать не с _любыми_ значениями, а только с определённым набором. У значений из таких наборов могут быть некоторые ограничения, например, мы можем запретить работу с отрицательными значениями базовой валюты. Такие ограничения мы тоже можем выразить в модели:

![Сужаем множество всех возможных значений до ограниченного набора значений, валидных в нашей предметной области](/images/content/explicit-design-series/01-normalize-base-value.png)

### Данные в виде типов

Если мы внимательно посмотрим на составленные преобразования, то увидим, что они очень похожи на «сигнатуры функций». И мы действительно можем превратить их в настоящие [функциональные типы](https://www.typescriptlang.org/docs/handbook/2/functions.html). Например, определение курса пары валют превратится в такой тип:

```ts
// domain/types.ts

type LookupRate = (rate: ExchangeRates, base: CurrencyCode, quote: CurrencyCode) => ExchangeRate;
```

Заметим, что для названий типов аргументов и результата функции мы выбрали термины предметной области, которые использовали на диаграммах.

Дело в том, что эти термины мы услышали от продукт-оунера, когда проводили исследование предметной области. Так мы поняли, что именно этими терминами «люди из бизнеса» описывают систему. Язык, который содержит эти термины, в DDD называется [_повсеместным (ubiquitous)_](https://martinfowler.com/bliki/UbiquitousLanguage.html), и мы используем в коде именно его.

Смысл повсеместного языка в том, чтобы уменьшить количество потерь при «переводе» с языка бизнеса на язык разработки. Используя его, мы как бы «конспектируем» то, что узнали во время исследования, но прямо в виде сигнатур функций. Так мы уменьшаем вероятность ошибки из-за использования неправильных терминов.

Так как типов `ExchangeRates`, `ExchangeRate` и `CurrencyCode` у нас ещё нет, TypeScript на нас ругнётся. Мы залатаем эту дыру, объявив [тайп-алиасы](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html#reusable-types-type-aliases) для этих типов:

```ts
// domain/types.ts

type CurrencyCode = unknown;
type ExchangeRate = unknown;
type ExchangeRates = unknown;
```

Для первого приближения этого вполне достаточно. Так как наша цель на ранних этапах — провалидировать представление о домене, алиасы помогают выразить мысли более формально, но во всё ещё относительно свободной форме, которую легко изменить. (Мы можем поменять название типа, добавить или удалить аргумент из сигнатуры функции, и при этом нам не потребуется обновлять много кода.)

<SideNote>
  Отметим также, что на этом этапе мы не делаем никаких обобщений, а наоборот описываем типы
  максимально полно и явно. Решение о том, обобщать ли какие-то данные или функции, мы примем позже,
  когда у нас будет [достаточно сведений](/blog/copy-paste/) о том, как на самом деле работает
  проект — когда модель станет точнее.
</SideNote>

Когда у нас появляется больше знаний о структурах данных, с которыми мы будем работать, мы можем вернуться к алиасам и уточнить типы. Например, когда мы узнали все доступные в приложении валюты, мы можем заменить тип `CurrencyCode` с `unknown` на настоящий:

```ts
// domain/types.ts

// Выяснили, что в приложении будет доступно 5 валют,
// описываем их как Union-тип из строковых литералов:

type CurrencyCode = "RPC" | "IMC" | "WPU" | "DRG" | "ZKL";
```

Исследуя предметную область дальше, мы могли узнать, что курс — это отношение между двумя числовыми значениями, и оно не имеет какой-либо единицы измерения. Тогда мы можем уточнить (сузить) тип `ExchangeRate`, обозначив, что это дробное число:

```ts
// domain/types.ts

type ExchangeRate = Fractional;

// Тип Fractional может быть просто числом, а может быть особым типом,
// который самостоятельно валидирует значения при создании.
// Пока что выразим его просто как число, и вернёмся позже, если потребуется:
type Fractional = number;
```

<SideNote>
  Вообще, алиасы — не самый надёжный способ вводить подобные ограничения в TypeScript, но для этапа
  проектирования — самый удобный. Мы позже поговорим о других способах следить за типами, вроде,
  [брендирования](https://medium.com/@KevinBGreene/surviving-the-typescript-ecosystem-branding-and-type-tagging-6cf6e516523d),
  но пока что нам будет достаточно алиасов.
</SideNote>

Далее мы можем выразить и сами котировки. Допустим, для каждой базовой валюты котировки описывают набор квот-валют и их курс. Тогда мы можем выразить котировки как объект, где ключами будут коды квот-валют, а значениями — их курс:

```ts
// domain/types.ts

// Набор курсов между текущей базовой валютой
// и всеми квот-валютами:

type ExchangeRates = Record<CurrencyCode, ExchangeRate>;
```

Каждое уточнение типов фиксирует больше информации о предметной области в сигнатурах. Это даёт несколько преимуществ:

- Мы уже можем искать ошибки в модели или места, где нам не хватает информации о предметной области. Когда мы как-либо формализуем идею «на бумаге», нам приходится держать одномоментно меньше информации в голове, а это улучшает внимание, и нам проще замечать нестыковки в модели.
- [Плотность кода становится выше](https://github.com/bespoyasov/refactor-like-a-superhero/blob/main/manuscript-ru/17-static-typing.md), потому что часть информации о предметной области мы выражаем через типы, и значит в реализации мы можем добавить больше деталей.
- Исправление модели на этом этапе очень дешёвое, потому что реализации ещё нет, и «донастраивать» понимание домена можно, всего лишь меняя названия типов и структуры данных.

### Ограничения домена в виде типов

Задача модели — описать работу предметной области, и важная часть такого описания — это её ограничения. Допустим, мы узнали, что в нашем конвертере базовая валюта будет всегда одна и та же — республиканский кредит (`RPC`).

Нынешняя модель этого ограничения не учитывает, например, функция `LookupRate` принимает любую валюту как базовую:

```ts
// domain/types.ts

type LookupRate = (
  rate: ExchangeRates,

  // Можно передать любую из 5 доступных валют:
  base: CurrencyCode,
  quote: CurrencyCode,
) => ExchangeRate;
```

С одной стороны — это «обобщение» и «задел на случай», если мы вдруг разрешим выбирать базовую валюту расчёта. Но с другой — так мы теряем важную _разницу_ между базовой и квот-валютой.

Пропущенная разница выражает _ограничения_ на количество возможных значений для каждой из валют. Согласно ней, базовая валюта может иметь только _одно_ значение, в то время как квот-валюта может быть любой из 5.

Различие в возможных значениях говорит нам, что перед нами на самом деле _2 отдельных типа_. Мы можем выразить эту разницу, разделив тип `CurrencyCode` на два отдельных:

```ts
// domain/types.ts

type BaseCurrencyCode = "RPC";
type QuoteCurrencyCode = "RPC" | "IMC" | "WPU" | "DRG" | "ZKL";
```

Теперь ограничение и разницу в поведении разных валют [видно прямо в типах](https://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/) их возможных значений. Потенциальных разночтений и скрытых деталей становится меньше, а сама модель точнее. Это особенно полезно при изучении проекта другими разработчиками в будущем, например, при онбординге.

<SideNote>
  По-хорошему нам бы ещё стоило отметить причину, почему базовая валюта у нас одна. Если мы можем
  выразить причину в типах или коде (например, с помощью названия или тип-алиасов), то лучше сделать
  это [прямо
  там](https://github.com/bespoyasov/refactor-like-a-superhero/blob/main/manuscript-ru/19-comments-and-docs.md).
  В другом случае можно указать эту причину в документации проекта.
</SideNote>

После уточнения модели мы заметим, что тип `LookupRate` можно упростить и убрать код базовой валюты из аргументов, так как он никогда не меняется:

```ts
// domain/types.ts

type LookupRate = (rate: ExchangeRates, quote: QuoteCurrencyCode) => ExchangeRate;
```

Ограничения в типах могут помочь [«запретить» некоторые невалидные состояния](https://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/) модели. Мы как будто отнимаем возможность в будущем написать некорректный (с точки зрения домена) код, потому что система типов не даст его скомпилировать.

<SideNote>
  Это конечно более полезно и надёжно в более зрелых языках, чем TypeScript, но для выразительности
  я всё же рекомендую использовать этот подход и в TS.
</SideNote>

### Другие процессы

Схожим образом, исследуя предметную область и опрашивая продукт-оунера и других участников проекта, мы можем описать остальные процессы. Например, расчёт значения квот-валюты относительно базовой по известному курсу будет выглядеть так:

```ts
// domain/types.ts

export type CalculateQuote = (base: BaseValue, rate: ExchangeRate) => QuoteValue;
```

А проверка полученного от пользователя значения и преобразование его в значение базовой валюты может быть выражено так:

```ts
// domain/types.ts

export type ToBaseValue = (raw: ValueCandidate) => BaseValue;
type ValueCandidate = number | string;
```

...И так далее до того момента, когда мы получим более-менее полное описание предметной области.

## Валидация и сверка модели

Представим, что мы собрали некоторое количество структур данных и их преобразований и выразили их в типах. Дальше нам бы хотелось оценить, насколько модель полна, и узнать, какие [уточнения могут потребоваться ещё](https://uxdesign.cc/the-knowns-and-unknowns-framework-for-design-thinking-6537787de2c5).

<SideNote>
  На этом этапе нам важно выявить неизвестные неизвестные [(unknown
  unknowns)](https://uxdesign.cc/the-knowns-and-unknowns-framework-for-design-thinking-6537787de2c5),
  чтобы оценить, достаточно ли деталей мы включили в модель.
</SideNote>

Один из способов проверить полноту — «проиграть» различные пользовательские сценарии, используя типы и структуры данных, которые у нас есть. Например, чтобы перевести одну валюту в другую, нам необходимо:

1. Получить коды валют и значение базовой из реального мира.
2. Определить текущий курс выбранной пары.
3. Рассчитать значение квот валюты по текущему курсу.

Если выразить этот алгоритм в сигнатурах и типах, то мы получим нечто вроде:

```ts
// 1. Получить данные из реального мира:
type GetInputData = () => ExchangeRates & QuoteCurrencyCode & BaseValue;

// 2. Определить курс:
type LookupRate = (r: ExchangeRates, q: QuoteCurrencyCode) => ExchangeRate;

// 3. Рассчитать значение:
type CalculateQuote = (b: BaseValue, r: ExchangeRate) => QuoteValue;
```

Пока что у нас нет функций для общения с реальным миром, поэтому первый шаг мы смоделировать не можем, но остальные шаги процесса мы выразили в типах успешно.

<SideNote>
  Сейчас мы считаем, что входные данные нам предоставляет _какая-то_ функция `GetInputData`, которая
  общается с внешним миром. В общем случае мы могли бы описать её тип подробнее, чтобы учесть
  источник данных, но для краткости я решил оставить это за рамками серии. Однако, если вам
  интересно, как это можно сделать, то советую прочесть [«Доменное моделирование в функциональном
  стиле»](/blog/domain-modelling-made-functional/) Скотта Влашина.
</SideNote>

Таким же образом мы можем проверить и другие пользовательские сценарии. Если созданных типов нам хватает, дополнительных вопросов по ходу дела не возникло, мы можем приступить к реализации модели в функциях.

## Функциональная реализация модели

Когда мы выразили часть домена в типах и проверили модель на непротиворечивость, мы можем приступить к реализации. Отметим, что реализация — это не «следующий шаг», а _часть проектирования_. Это значит, что если во время реализации у нас возникают вопросы о работе домена, нам стоит остановиться и задать вопросы продукт-оунеру, чтобы уточнить модель.

<SideNote>
  Проектирование и разработка — это в целом [итеративный
  процесс](https://evilmartians.com/chronicles/design-first-then-build-lets-bury-this-myth-forevermore).
  Это нормально возвращаться иногда на шаг-два назад, чтобы улучшить модель и добавить свежую
  информацию. В будущем я перестану обращать на это внимание, но условимся, что часто вносить
  изменения — это обычное дело.
</SideNote>

Мы воспользуемся фактом, что TypeScript мультипарадигменный и напишем реализацию модели в около-функциональном стиле. Наш код не будет чисто функциональным, но мы постараемся выжать максимум из базовых концепций ФП: чистых функций, частичного применения, функциональной композиции и замыканий.

Такой подход с одной стороны не будет чрезмерно сложным (мы ни разу не упомянем [монады](http://learnyouahaskell.com/a-fistful-of-monads) 🙃), а с другой — мы получим высокую тестируемость, отлаживаемость, сделаем модель явной и компонуемой.

### Чистые функции

Основа функционального подхода — это [чистые функции](https://en.wikipedia.org/wiki/Pure_function). _Чистыми_ называют функции, которые не производят сайд-эффектов и всегда возвращают одинаковый результат при одинаковых аргументах.

Одно из полезных свойств таких функций в том, что они заставляют нас разделять данные и действия над ними. Данные и код [меняются с разной частотой](https://blog.ploeh.dk/2023/03/27/more-functional-pits-of-success/) и их смешение делает систему неустойчивой к изменениям. Когда же они разделены, обновлять код становится проще, сами действия получаются явными, а преобразования, которые проходят данные, — видимыми.

<SideNote>
  Кстати, разделение данных и действий — одна из основных концепций не только ФП, но [и DDD
  тоже](https://martinfowler.com/bliki/EvansClassification.html).
</SideNote>

Чтобы понять силу чистых функций, посмотрим на пример. Ниже результат функции `createBaseValue` зависит только от своего аргумента, и мы можем быть уверены, что при передаче одного и того же значения мы получим одинаковый результат:

```ts
export const createBaseValue: ToBaseValue = (raw) => {
  const candidate = Number(raw);
  return Number.isNaN(candidate) ? 0 : Math.abs(candidate);
};

// Строго говоря, на результат ещё влияют функции `isNaN` и `abs`,
// но для простоты мы подразумеваем, что они тоже чистые.
```

Уверенность, что мы получим определённый результат, помогает _абстрагировать_ менее важные детали и сосредоточиться на более высокоуровневых процессах. В нашем случае функция `createBaseValue` как бы «упаковывает в себя» детали того, как преобразовать сырое значение к доменному типу.

Это даёт нам возможность [строить более сложные процессы](https://www.goodreads.com/book/show/57345272-code-that-fits-in-your-head), используя эти функции как _составные части_ таких процессов:

```ts
const rawValue = "42";
const baseValue = createBaseValue(rawValue);
const quoteValue = calculateQuoteValue(currentRate, baseValue);

// Данные проходят через несколько этапов:
// RawValue -> BaseValue -> QuoteValue
// "42"     -> 42        -> 1.46
```

А так как мы уверены, что при одинаковых аргументах получим одинаковый результат, то можем заменить часть процесса _результатом_ вызова функций, составляющих этот процесс:

```ts
const baseValue = 42;
const quoteValue = calculateQuoteValue(currentRate, baseValue);

// Получим тот же результат, потому что функция `createBaseValue` чистая
// и мы можем заменить её вызов на результат.
```

Это свойство называется [_ссылочной прозрачностью_](https://wiki.haskell.org/Referential_transparency), и оно помогает фокусироваться на интересующих нас частях процесса, абстрагируя детали предыдущих частей:

![Когда преобразование данных ссылочно-прозрачно, мы можем ставить «разрывы» в любых его местах и проверять работу любой его части, без необходимости проигрывать весь процесс целиком](/images/content/explicit-design-series/01-referential-transparency.png)

Так ссылочная прозрачность и чистые функции делают доменную модель удобной для проверки, тестирования и визуализации потоков данных.

### Согласованность данных

Ссылочную прозрачность и удобство чистых функций мы можем использовать для формализации [_инвариантов модели_](<https://en.wikipedia.org/wiki/Invariant_(mathematics)#Invariants_in_computer_science>) — правил и свойств данных, которые должны всегда выполняться.

Например, функция `createBaseValue` _гарантирует_, что значение на выходе всегда будет числом, большем или равном 0. Это свойство выходного значения — инвариант.

Функция говорит нам, что значения типа `BaseValue` могут быть только числами в определённом диапазоне `[0, Infinity)`, и все значения «из внешнего мира» должны пройти через этот «фильтр» прежде, чем попасть в доменную модель. Инварианты помогают держать данные внутри модели _согласованными_, то есть [внутренне непротиворечивыми](https://en.wikipedia.org/wiki/Data_consistency).

<SideNote>
  Стремление к согласованности, кстати, тоже вынуждает нас искать ошибки в модели на ранних этапах
  проектирования, когда вносить изменения в код ещё относительно дёшево.
</SideNote>

Так как правило нормализации значения находится целиком и полностью внутри функции `createBaseValue`, остальному коду модели не нужно беспокоиться о валидности значения типа `BaseValue` — это берёт на себя [функция-фабрика](https://refactoring.guru/design-patterns/factory-method) `createBaseValue`. Такой [_контракт_ между модулями](https://wiki.c2.com/?DesignByContract) помогает разделить обязательства и ограничить изменения кода в будущем.

Остальной код знает, что если тип значения — `BaseValue`, то значение вышло из функции `createBaseValue` и по определению валидно. Другие функции могут использовать это значение, _рассчитывая на этот факт_ и не проверяя значение снова. В итоге правила валидации собраны в одном месте и не разбросаны по коду модели.

<SideNote>
  Контракты между модулями — это основа низкого зацепления. Подробнее о зацеплении и связности мы
  поговорим в следующих постах.
</SideNote>

<SideNote>
  Понятно, что в TS можно обойти это ограничение и закастовать тип `BaseValue` на что угодно. Тогда,
  конечно, контракт будет нарушен и ни на какие гарантии функции могут не рассчитывать. С этим можно
  бороться разными способами, но мы для краткости будем рассматривать вариант, когда значения типа
  `BaseValue` появляются только из фабрики.
</SideNote>

### Инкапсуляция

Другим примером контракта и обрамления правил может быть функция `lookupRate`. Эта функция содержит правило поиска курса между парой выбранных валют:

```ts
export const lookupRate: LookupRate = (rates, against) => rates[against];
```

Эта функция освобождает остальные от необходимости знать, откуда берётся значение курса выбранной пары валют. Остальные функции могут положиться на гарантии (контракт), что результат вызова `lookupRate` всегда будет правильным и валидным курсом.

Функция `lookupRate` гарантирует, что курс будет валиден, даже если структура `ExchangeRates` изменится. Она позаботится о том, чтобы _правильно_ достать нужные данные из `ExchangeRates` и предоставить их как результат.

Такое поведение, когда модуль самостоятельно гарантирует валидность данных и знает, как её обеспечить, [называется _инкапсуляцией_](https://www.goodreads.com/book/show/57345272-code-that-fits-in-your-head). Она позволяет нам ограничить распространение изменений кода при обновлении типа `ExchangeRates`:

```ts
type ExchangeRates = Record<CurrencyCode, ExchangeRate>;
type UpdatedExchangeRate = List<[CurrencyCode, ExchangeRate]>;

// До изменения мы доставали данные одним образом:
const lookupRate = (rates, against) => rates[against];

// После — несколько иначе:
const lookupRate = (rates, against) => rates.find(([code, rate]) => code === against).at(1);

// Но весь код, который полагался на вызов `lookupRate`,
// остался неизменным, потому что изменения ограничены функцией `lookupRate`:
const currentRate = lookupRate(exchangeRates, "IMC");
```

Так остальной код может быть уверен, что пока он корректно вызывает функцию `lookupRate` и передаёт ей все необходимые аргументы (выполняет свою часть контракта), как результат он получит валидный курс текущей пары валют (функция `lookupRate` выполнит свою часть контракта).

### Естественная тестируемость

Чуть выше мы упоминали, что чистые функции помогают делать модель легко проверяемой. Здесь всё дело в том, что чистые функции по своей природе [естественно тестируемы](https://blog.ploeh.dk/2015/05/07/functional-design-is-intrinsically-testable/) — они не требуют сложной тестовой инфраструктуры, их тесты не нужно долго настраивать, а для их запуска нужно только входные данные и ожидаемый результат.

Например, для проверки работы `createBaseValue` мы можем написать вот такой тест:

```ts
describe("when given a number-like value", () => {
  const expected = 42;
  const cases = [42, -42, "42"];

  it.each(cases)("returns the domain base value", (value) => {
    const result = createBaseValue(value);
    expect(result).toEqual(expected);
  });
});
```

Этот тест просто понять, легко написать, и он отлично встраивается в [парадигму AAA (Arrange, Act, Assert)](http://wiki.c2.com/?ArrangeActAssert=):

```ts
describe("when given a number-like value", () => {
  // Arrange:
  const expected = 42;
  const cases = [42, -42, "42"];

  it.each(cases)("returns the domain base value", (value) => {
    // Act:
    const result = createBaseValue(value);

    // Assert:
    expect(result).toEqual(expected);
  });
});
```

Всё это делает проверку чистых функций прямолинейной. Нам не нужно думать о том, _что и как_ мы будем тестировать, потому что у чистых функций есть лишь одно место, которое мы можем протестировать — возвращаемый результат.

Простые тесты удобны в поддержке и более [устойчивы к изменениям](https://dhh.dk/2014/test-induced-design-damage.html), потому что у простой тестовой инфраструктуры меньше точек отказа — её реже нужно чинить после обновления библиотек, реже придётся переписывать сами тесты, потому что «сломать» входные и выходные данные сложнее, чем, например, моки.

Для юнит-тестирования чистые функции тоже отлично подходят, потому что простые тесты не требуют много ресурсов. Так как нам не нужно создавать провайдеры, рендеры, обёртки, моки и т.д., тесты чистых функций будут в среднем быстрее.

Наконец, чистые функции удобно тестировать не только на [happy path](https://en.wikipedia.org/wiki/Happy_path), но и на отказные случаи. Например, для `createBaseValue` мы можем написать такой набор отказных тестов:

```ts
describe("when given a non-number value", () => {
  const cases = ["string", "42n", NaN, [], null, undefined, {}];

  it.each(cases)("returns 0 base value", (value) => {
    const result = createBaseValue(value);
    expect(result).toEqual(0);
  });
});
```

### Разработка через тестирование

Ссылочная прозрачность, естественная тестируемость, контракты на поведение и типы данных и процессов предметной области позволяют использовать при моделировании ещё один инструмент — _разработку через тестирование, TDD (Test-Driven Development)_.

[TDD](/blog/tdd-what-how-and-why/) — это методология, в которой мы сперва пишем тесты для функции, которую собираемся реализовать, и только потом саму функцию. Основная идея TDD — двигаться маленькими шагами и развивать код короткими итерациями, развивая его от простейшей реализации до необходимой по сложности версии.

<SideNote>
  Я не буду подробно рассказывать о самом подходе в этом посте, но если вам интересно почитать о TDD
  в деталях, то я рекомендую прочитать мой [пост о TDD](/blog/tdd-what-how-and-why/), [книжку с
  примерами](https://bespoyasov.ru/ttt-tdd/) и большой [стрим о тестировании
  React-приложений](/talks/testing-workshop/). Кроме этого советую прочитать [книгу Владимира
  Хорикова](https://www.goodreads.com/book/show/48927138-unit-testing) о юнит-тестировании.
</SideNote>

Я понимаю, что не всем разработчикам нравится работать по TDD, и это нормально; я не собираюсь «продавать» кому-либо эту методологию. Моя цель в этом посте — показать, как использовать TDD в качестве [инструмента для проектирования домена](https://blog.ploeh.dk/2015/05/07/functional-design-is-intrinsically-testable/), чтобы у вас было больше сведений для принятия решения, использовать ли его.

Попробуем для наглядности написать функцию, реализующую тип `CalculateQuote`, по TDD. Для начала мы можем описать границы функциональности, которую собираемся реализовать, с помощью [`.todo()`](https://vitest.dev/api/#test-todo):

```ts
// Опишем, какую функциональность хотим получить в результате:

describe("when given a base value and the current rate", () => {
  it.todo("returns the correct quote value");
  it.todo("should have a precision of two decimal places");
});
```

На этом этапе у нас могут возникнуть дополнительные вопросы к работе модели. Например, как обрабатывать краевые случаи или какие данные мы готовы и не готовы принимать.

На деле новые вопросы — это хорошо, потому что формализуя через `.todo` скоуп функциональности, мы _уточняем модель_. Каждый вопрос о поведении системы добавляет больше знаний из реального мира в код, делая модель точнее. При этом непосредственно _кода_ функции у нас ещё нет, а значит вносить изменения в модель — дёшево.

Когда мы определились с тем, как должна себя вести функция `calculateQuote`, мы можем написать первый тест. Опишем поведение функции при корректных входных данных:

```ts
type TestCase = {
  base: BaseValue;
  rate: ExchangeRate;
  expected: QuoteValue;
};

// ...

it.each<TestCase>([{ base: 10, rate: 1, expected: 10 }])(
  "returns the correct quote value",
  ({ base, rate, expected }) => {
    const result = calculateQuote(base, rate);
    expect(result).toEqual(expected);
  },
);
```

Далее нам надо удостовериться, что тест _падает_. Это важно, потому что только падающий тест действительно что-то проверяет, а мы хотим удостовериться, что наши тесты не бесполезны.

Затем мы должны проверить _причину_, по которой падает тест. Сейчас тест падает, потому что функция `calculateQuote` не определена. Это совсем не то, чего мы ожидаем в тесте. Поэтому добавим функцию и убедимся, что тест падает по нужной нам причине:

```ts
const calculateQuote: CalculateQuote = (base, rate) => 42;
```

Получим такой отчёт:

```
19|   ])("returns the correct quote value", ({ base, rate, expected }) => {
20|     const result = calculateQuote(base, rate);
21|     expect(result).toEqual(expected);
  |                    ^
22|   });
23|

- Expected   "10"
+ Received   "42"
```

Теперь, когда мы увидели, что причина совпадает, мы можем приступить к настоящей реализации. Это важно, потому что мы хотим быть уверены, что тесты валидируют наши ожидания от модели (правила, инварианты и преобразования данных). Когда мы заставляем тест падать по нужной нам причине, мы убеждаемся, что тест проверяет верное ожидание.

<SideNote>
  Вообще, по канону TDD первый тест и его реализация должны быть максимально простыми, чтобы цикл
  разработки был коротким — не более 5 минут. В этом посте я решали немного срезать углы и
  пропустить этот аспект для краткости рассказа. Но опять же, в конце я оставлю дополнительные
  материалы на эту тему.
</SideNote>

Далее можем написать настоящую реализацию:

```ts
const calculateQuote: CalculateQuote = (base, rate) => base * rate;
```

Когда первый тест проходит, мы можем уделить время рефакторингу кода или тестов и, например, добавить других тестовых случаев, чтобы ухватить чуть больше вариантов поведения:

```ts
it.each<TestCase>([
  { base: 10, rate: 1, expected: 10 },
  { base: 10, rate: 2, expected: 20 },
  { base: 10, rate: 4.2, expected: 42 },
]); // ...
```

После этого нам обязательно надо проверить, что все написанные тесты проходят. В этом тоже плюс TDD, потому что каждый шаг разработки страхуется уже написанными тестами. (Понятно, что качество такой страховки зависит от качества написанных тестов, но это немного другой вопрос.)

Далее можем описать тесты для второго случая, чтобы убедиться, что функция округляет дроби до 2 знаков после запятой:

```ts
it.each<TestCase>([
  { base: 10, rate: 1.12, expected: 11.2 },
  { base: 10, rate: 0.72, expected: 7.2 },
])("should have a precision of two decimal places", ({ base, rate, expected }) =>
  expect(calculateQuote(base, rate)).toEqual(expected),
);
```

Убеждаемся, что тесты падают, потому что округления нет. После чего пишем реализацию:

```ts
const calculateQuote: CalculateQuote = (base, rate) => Number((base * rate).toFixed(2));
```

...И проверяем, что все тесты проходят. Таким же образом мы можем описать отказные случаи для работы этой функции и спроектировать другие аспекты её поведения.

### Композиция функций

Как мы уже упоминали, полезное свойство функционального подхода при моделировании домена в том, что он _побуждает нас отделять данные от действий_ над ними.

Мы можем увидеть эту разницу, просто взглянув на типы нашей модели:

```ts
// Данные:
type BaseCurrencyCode = "RPC";
type QuoteCurrencyCode = "RPC" | "IMC" | "WPU" | "DRG" | "ZKL";
type ExchangeRates = Record<QuoteCurrencyCode, ExchangeRate>;

// Преобразования данных:
type LookupRate = (r: ExchangeRates, q: QuoteCurrencyCode) => ExchangeRate;
type CalculateQuote = (b: BaseValue, r: ExchangeRate) => QuoteValue;
```

Такое разделение помогает нам делать явными все _этапы_, через которые проходят данные. Когда все действия видны, а их результат предсказуем, модель содержит меньше _скрытых_ деталей, которые могут влиять на финальное состояние данных.

Доменные процессы становятся последовательными наборами действий, а их результаты мы можем визуализировать (или даже «проиграть в голове») и предсказать, какой вид примут данные в конце:

```ts
const rawValue = "42";
const baseValue = createBaseValue(rawValue);
const quoteValue = calculateQuoteValue(currentRate, baseValue);

// RawValue -> BaseValue -> QuoteValue
```

Такие процессы легко [собирать в более сложные функции](https://en.wikipedia.org/wiki/Function_composition):

```ts
function workflow(rawValue, exchangeRates) {
  const baseValue = createBaseValue(rawValue);
  const currentRate = lookupRate(exchangeRates);
  const quoteValue = calculateQuoteValue(currentRate, baseValue);
  return quoteValue;
}
```

...Но преобразование целиком при этом остаётся понятным и тестируемым, потому что все его этапы на виду.

Мы в этом подходе не меняем состояние вокруг функции, а вместо этого возвращаем обновлённый набор данных, из-за чего на финальный результат нельзя повлиять извне. Так мы [исключаем влияние сайд-эффектов](https://blog.ploeh.dk/2016/09/26/decoupling-decisions-from-effects/) на результат.

В будущем мы будем использовать функциональную композицию, чтобы собирать пользовательские сценарии и выделять одинаковые действия в отдельные функции.

<SideNote>
  На нынешнем этапе делать какие-либо обобщения ещё рано. Сперва нам стоит посмотреть как данные на
  самом деле себя ведут: какие данные меняются одновременно с другими, как часто это происходит и по
  каким причинам. После того, как мы обнаружим связность, мы сможем сделать вывод о необходимости
  обобщений.
</SideNote>

## В следующий раз

В этом посте мы спроектировали доменную модель приложения и заложили основу для будущей работы над пользовательскими сценариями. [В следующий раз](/blog/explicit-design-2) мы спроектируем и реализуем юзкейсы, опишем спецификации того, как внешний мир должен общаться с приложением, и поговорим о зависимостях внутри приложения и снаружи.

## Ссылки

Все ссылки на книги, статьи и другие материалы, упомянутые в статье.

- [Исходный код этапа разработки на Гитхабе](https://github.com/bespoyasov/explicit-design/tree/main/01-domain-modelling)
- [Блог на Гитхабе на случай опечаток](https://github.com/bespoyasov/www)

### Книги

- [Code That Fits in Your Head. Mark Seemann](https://www.goodreads.com/book/show/57345272-code-that-fits-in-your-head)
- [Domain-Driven Design. Eric Evans](https://www.goodreads.com/book/show/179133.Domain_Driven_Design)
- [Domain Modelling Made Functional. Scott Wlaschin](/blog/domain-modelling-made-functional/)
- [Unit Testing: Principles, Practices, and Patterns. Vladimir Khorikov](https://www.goodreads.com/book/show/48927138-unit-testing)
- [TTT-TDD. Пример разработки «Крестиков‑ноликов» по TDD](https://bespoyasov.ru/ttt-tdd/)

### Доменное моделирование

- [Data consistency](https://en.wikipedia.org/wiki/Data_consistency)
- [Domain-driven design](https://martinfowler.com/bliki/DomainDrivenDesign.html)
- [Domain model](https://martinfowler.com/eaaCatalog/domainModel.html)
- [Evans classification](https://martinfowler.com/bliki/EvansClassification.html)
- [Ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html)
- [Инвариант, Википедия](<https://ru.wikipedia.org/wiki/Инвариант_(математика)>)

### Архитектура, контракты, паттерны

- [DDD, Hexagonal, Onion, Clean, CQRS, … How I put it all together](https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/)
- [Design by contract](https://wiki.c2.com/?DesignByContract)
- [More functional pits of success](https://blog.ploeh.dk/2023/03/27/more-functional-pits-of-success/)
- [Ports & adapters architecture](https://herbertograca.com/2017/09/14/ports-adapters-architecture/)
- [Фабричный метод](https://refactoring.guru/ru/design-patterns/factory-method)

### TypeScript и статическая типизация

- [Designing with types: Making illegal states unrepresentable](https://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/)
- [Functional types](https://www.typescriptlang.org/docs/handbook/2/functions.html)
- [Type aliases](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html#reusable-types-type-aliases)
- [Type branding](https://medium.com/@KevinBGreene/surviving-the-typescript-ecosystem-branding-and-type-tagging-6cf6e516523d)
- [Статическая типизация как инструмент проектирования](https://github.com/bespoyasov/refactor-like-a-superhero/blob/main/manuscript-ru/17-static-typing.md)

### Функциональное программирование

- [Decoupling decisions from effects](https://blog.ploeh.dk/2016/09/26/decoupling-decisions-from-effects/)
- [A fistful of monads](http://learnyouahaskell.com/a-fistful-of-monads)
- [Referential transparency](https://wiki.haskell.org/Referential_transparency)
- [Композиция функций, Википедия](https://ru.wikipedia.org/wiki/Композиция_функций)
- [Чистота функций, Википедия](https://ru.wikipedia.org/wiki/Чистота_функции)

### Тестирование

- [Arrange / act / assert](http://wiki.c2.com/?ArrangeActAssert=)
- [Functional design is intrinsically testable](https://blog.ploeh.dk/2015/05/07/functional-design-is-intrinsically-testable/)
- [Happy path](https://en.wikipedia.org/wiki/Happy_path)
- [Test-induced design damage](https://dhh.dk/2014/test-induced-design-damage.html)
- [Vitest API reference](https://vitest.dev/api/)
- [TDD: зачем и как](/blog/tdd-what-how-and-why/)
- [Пример разработки «Крестиков-ноликов» по TDD](https://bespoyasov.ru/ttt-tdd/)

### Процессы, методологии и прочее

- [“Design first, then build”: let’s bury this myth forevermore](https://evilmartians.com/chronicles/design-first-then-build-lets-bury-this-myth-forevermore)
- [The knowns and unknowns framework for design thinking](https://uxdesign.cc/the-knowns-and-unknowns-framework-for-design-thinking-6537787de2c5)
- [CRUD](https://ru.wikipedia.org/wiki/CRUD)
- [Копипаста в коде](/blog/copy-paste/)
- [Отношение сигнал/шум, Википедия](https://ru.wikipedia.org/wiki/Отношение_сигнал/шум)
- [Рядом с кодом: как управлять процессами улучшения документации](https://github.com/bespoyasov/refactor-like-a-superhero/blob/main/manuscript-ru/19-comments-and-docs.md)

### Другие части серии

- [Введение, предпосылки и ограничения](/blog/explicit-design-series)
- Моделирование предметной области (этот пост)
- [Проектирование пользовательских сценариев](/blog/explicit-design-2)
- [Описание UI как «адаптера» к приложению](/blog/explicit-design-3)
- [Создание инфраструктуры под нужды сценариев](/blog/explicit-design-4)
- [Композиция приложения в хуках](/blog/explicit-design-5)
- [Композиция приложения без хуков](/blog/explicit-design-6)
- Внедрение cross-cutting concerns
- Расширение функциональности новой фичей
- Расцепление фич приложения
- Обзор и предварительные выводы
