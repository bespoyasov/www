export const metadata = {
  title: "Когда последовательность важнее правильности",
  description: "Когда иначе — слишком сложно.",
  datetime: "2019-03-04T11:00",
  tags: ["Opinion", "Advice", "Editorial"],
  slug: "/blog/consistency-vs-correctness",
};

# Когда последовательность важнее правильности

Пост будет холиварный, читайте с осторожностью.

Представьте ситуацию: приходит задача дополнить валидацию данных пользователя, которую писали до вас. Вы открываете код и видите:

```
const validateUserData = (userData) => {
  const {socialNumber, email} = userData
  return validateSocialNumber(socialNumber)
    || validateEmail(email)
}
```

Вы знаете, что все поля обязательные, и вам непонятно, почему возвращается истина если валидно хотя бы одно значение, а не всё вместе.

Вы открываете код функций _validateSocialNumber_ и _validateEmail_ и видите, что они возвращают истину, если в данных есть ошибка. Откуда делаете вывод, что и _validateUserData_ возвращает истину, если есть ошибка (наверное, на то были причины ¯\\\_(ツ)\_/¯). Беглый просмотр кодовой базы показал, что таких функций много, они встречаются в разных модулях, и быстро исправить всё не получится.

Ваша задача — добавить проверку почты и сделать это «ВЧЕРА!!!». Из-за сроков отрефактироить код перед этим не успевается (напомню, подобных функций много). Вы понимаете, что правильнее — написать новую функцию так, чтобы она возвращала истину, если ошибок нет...

<mark>
  Но прямо сейчас последовательность — важнее правильности, и первый шаг — сделать по аналогии,
  сделать «неправильно»
</mark>

Иначе с добавлением «правильной функции» схожие сущности (функции, которые названы по одному принципу) начнут вести себя по-разному. Из-за чего сильно вырастет когнитивная нагрузка, ведь придётся постоянно держать в голове, какая функция возвращает истину при ошибке, а какая — при валидном значении.

Когда задача решена, уже можно (и нужно) отправиться в рефакторинг-поход и всё переделать. Но до этого момента между последовательностью и правильностью, стоит выбрать первое.
